<!DOCTYPE html>
<html lang="uk">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Q&amp;A</title>

    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/modern-normalize@2.0.0/modern-normalize.min.css"
    />
    <link rel="stylesheet" href="./css/styles.css" />
  </head>

  <body>
    <header>
      <nav class="nav">
        <ul class="nav-list">
          <li>
            <a href="./index.html" class="nav-link">HTML/CSS</a>
          </li>
          <li class="nav-item">
            <a href="./js.html" class="nav-link current">JavaScript</a>
          </li>
          <li class="nav-item">
            <a href="./react.html" class="nav-link">React</a>
          </li>
        </ul>
      </nav>
    </header>

    <main>
      <h1 class="visually-hidden">JavaScript</h1>

      <ol class="question-list">
        <li class="question">Які типи даних присутні в JavaScript?</li>
        <div class="answer">
          <p class="answer-text">
            Існує 8 типів даних. 7 примітивних та 1 складний тип даних.
          </p>
          <p class="answer-text">
            Примітивні типи: number, string, boolean, symbol, bigInt, null,
            undefined.
          </p>
          <p class="answer-text">
            Складний тип - object. Він використовується для колекцій даних та
            для оголошення більш складних сутностей. Також до object відносяться
            масиви і функції.
          </p>
          <p class="answer-text">
            Object передається за посиланням, а прості типи даних за значенням.
          </p>
        </div>
        <hr />

        <li class="question">Що таке NaN?</li>
        <div class="answer">
          <p class="answer-text">
            NaN (not a number) - це значення, що отримується в результаті
            виконання числової операції над не числовим значенням (наприклад,
            множення або ділення рядка, або приведення рядка, який не містить
            числа, дор типу даних number). Його тип даних number. NaN не
            дорівнює самому собі. Перевірку на NaN можна зробити за допомогою
            Number.isNaN
          </p>
        </div>
        <hr />

        <li class="question">Яка різниця між null та undefined?</li>
        <div class="answer">
          <p class="answer-text">
            undefined (невизначений) являє собою значення за замовчуванням для:
          </p>
          <ul class="answer-ul">
            <li>змінної, яку оголосили без ініціалізації;</li>
            <li>функції, яка нічого не повертає явно через return;</li>
            <li>властивості об'єкта, що не існує.</li>
            <!-- вказує на невизначеність значення змінної, тобто каже нам, що значення на даний момент невідоме чи невизначене.
              — undefined вказує на невизначеність значення змінної. -->
          </ul>
          <p class="answer-text">
            null - це значення «відсутності значення». Присвоюється змінній
            явно. Цікавою особливістю null є те, що typeof null повертає object,
            тому щоб перевірити значення на null необхідно використовувати
            оператор строгої рівності.
            <!-- null явно вказує на відсутність значення та часто використовується розробниками для позначення порожнього значення. Це значення має бути явно присвоєно змінній, щоб вказати, що змінна не містить ніяких дійсних даних.
              — null використовується для явної вказівки порожнього значення (точно відомо, що значення немає). -->
            <!-- Причина цього полягає в тому, що в ранніх версіях JavaScript null було розглянуто як спеціальний випадок об’єкта. Це була помилка в реалізації мови, збережена для забезпечення зворотної сумісності з існуючим кодом. Тому коли typeof застосовується до null, він повертає object, щоб зберегти цю сумісність. -->
          </p>
        </div>
        <hr />

        <li class="question">
          Чим відрізняється строга і не строга рівність (=== та ==)?
        </li>
        <div class="answer">
          <p class="answer-text">
            Не строга приводить значення до одного типу, а потім ці значення
            порівнює.
          </p>
          <p class="answer-text">
            Наприклад, якщо порівнювати null та undefined через не строгу
            рівність, буде отримано true, тому що і null і undefined приводяться
            до типу boolean, та їх значення будуть false (false дорівнює false).
            Так саме буде true і в випадку порівняння нуля (0) та порожнього
            рядка (""), або порівняння нуля (0) та буля false (але в ціх
            випадках буде виконано неявне приведення рядка та буля до number:
            false => 0, "" => 0).
            <a
              href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Equality"
              target="_blank"
              >Детальніше в документації MDN</a
            >.
          </p>
          <p class="answer-text">
            Строга рівність порівнює значення за типом даних та значенням.
          </p>
          <p class="answer-text">
            При строгому порівнянні null не буде дорівнювати undefined (різні
            типа даних), нуль (0) не буде дорівнювати порожньому рядку ("") або
            булю false, а 1 (number) не буде дорівнювати "1" (string).
          </p>
        </div>
        <hr />

        <li class="question">
          Чому результатом порівняння двох схожих об'єктів є false?
        </li>
        <div class="answer">
          <p class="answer-text">
            Тому що об'єкти - це типи даних, що передаються за посиланням. Коли
            оголошуються дві змінні з однаковими на вигляд об'єктами, то в них
            записуються посилання на місця в пам'яті, де зберігаються ці
            об'єкти, та при порівнянні ціх посилань буде отримано false.
          </p>
        </div>
        <hr />
        <!-- marker -->
        <li class="question">Як перевірити два об'єкти на ідентичність?</li>
        <div class="answer">
          <ol class="answer-ol">
            <li>
              Використовувати JSON.stringify для приведення об'єктів у рядок та
              порівняти їх вже як 2 рядки. Такий підхід має обмеження. Якщо в
              об'єкті будуть методи або symbol - JSON.stringify не зможе
              конвертувати їх у рядок.
            </li>
            <li>
              Написати або використати з бібліотеки функцію deepEqual, яка буде
              проходити циклом по ключах двох об'єктів і перевірятиме значення
              цих ключів. Функція має працювати рекурсивно.
            </li>
          </ol>
        </div>
        <hr />

        <li class="question">Як зробити копію об'єкта?</li>
        <div class="answer">
          <p class="answer-text">
            Існує поняття глибокого та поверхневого копіювання.
          </p>
          <p class="answer-text">
            Глибоке - це копіювання об'єкта та всіх його рівнів вкладеності.
            Способи глибокого копіювання:
          </p>
          <ol class="answer-ol">
            <li>
              Використовувати JSON.stringify - JSON.parse для конвертування
              об'єкта в рядок і потім назад. Має обмеження щодо копіювання
              методів та symbols.
            </li>
            <li>
              Написати або використати з бібліотеки функцію deepClone яка буде
              рекурсивно проходитиме за ключами об'єкта та копіюватиме їх у
              новий об'єкт.
            </li>
          </ol>
          <p class="answer-text">
            Поверхневе - це копіювання лише першого рівня вкладеності, а для
            решти копіюється посилання. Способи поверхневого копіювання:
          </p>
          <ol class="answer-ol">
            <li>Використовувати spread оператор (...).</li>
            <li>Використовувати Object.assign().</li>
          </ol>
        </div>
        <hr />

        <li class="question">Чим відрізняються змінні var, let та const?</li>
        <div class="answer">
          <ul class="answer-ul">
            <li>
              var - змінну можна ініціалізувати після оголошення, можна
              змінювати, має функціональну область видимості, має hoisting.
              Зараз майже не використовують під час написання нового коду;
            </li>
            <li>
              let - змінну можна ініціалізувати після оголошення, можна
              змінювати, має блокову область видимості, не має hoisting;
            </li>
            <li>
              const - змінну обов'язково потрібно ініціалізувати під час
              оголошення, не можна змінювати, має блокову область видимості, не
              має hoisting.
            </li>
          </ul>
        </div>
        <hr />

        <li class="question">Як дізнатися чи є об'єкт масивом?</li>
        <div class="answer">
          <p class="answer-text">
            Для цього можна використати метод Array.isArray.
          </p>
        </div>
        <hr />

        <li class="question">Які перебираючи методи масивів ви знаєте?</li>
        <div class="answer">
          <p class="answer-text">Є наступні методи:</p>
          <ul class="answer-ul">
            <li>forEach - для перебору масиву;</li>
            <li>filter - для фільтрації масиву;</li>
            <li>every/some - для перевірки масиву;</li>
            <li>map - для трансформації масиву в масив;</li>
            <li>
              reduce/reduceRight - для проходу по масиву з обчисленням значення;
            </li>
            <li>sort - сортує масив.</li>
          </ul>
        </div>
        <hr />

        <li class="question">Як об'єднати масиви?</li>
        <div class="answer">
          <ol class="answer-ol">
            <li>Використовувати метод concat().</li>
            <li>
              Використовувати spread оператор та об'єднати ці масиви в один
              загальний масив.
            </li>
          </ol>
        </div>
        <hr />

        <li class="question">Як дізнатися чи знаходиться елемент у масиві?</li>
        <div class="answer">
          <ol class="answer-ol">
            <li>
              Використати метод includes, який повертає true якщо елемент
              знаходиться у масиві.
            </li>
            <li>
              Використати метод indexOf який повертає індекс знайденого елемента
              в масиві або -1 якщо елемента в масиві немає.
            </li>
            <li>
              Використати метод find, який повертає знайдений елемент, або
              повертає undefined.
            </li>
          </ol>
        </div>
        <hr />

        <li class="question">Що таке підняття (hoisting)?</li>
        <div class="answer">
          <p class="answer-text">
            Це механізм у JavaScript, в якому змінні типу var та оголошення
            функцій, пересуваються вгору своєї області видимості перед тим, як
            код буде виконаний.
          </p>
        </div>
        <hr />

        <li class="question">
          Яким буде значення змінної var, якщо звернутися до неї до її
          оголошення?
        </li>
        <div class="answer">
          <p class="answer-text">Значенням змінної буде undefined.</p>
        </div>
        <hr />

        <li class="question">
          Що буде, якщо звернутися до змінної let/const до її оголошення?
        </li>
        <div class="answer">
          <p class="answer-text">
            Буде помилка типу ReferenceError. Змінної ще не існує.
          </p>
        </div>
        <hr />

        <li class="question">Що таке область видимості (Scope)?</li>
        <div class="answer">
          <p class="answer-text">
            Це місце, де (або звідки) ми маємо доступ до змінних або функцій. В
            JavaScript існує 4 типи областей видимості:
          </p>
          <ul class="answer-ul">
            <li>глобальна,</li>
            <li>функціональна,</li>
            <li>блокова (ES6),</li>
            <li>область видимості eval.</li>
          </ul>
        </div>
        <hr />

        <li class="question">
          Чим Function Declaration відрізняється від Function Expression?
        </li>
        <div class="answer">
          <p class="answer-text">
            Function Expression створюється, коли виконання доходить до нього, а
            потім вже може використовуватися.
          </p>
          <p class="answer-text">
            Function Declaration можна використовувати у всьому скрипті (або
            блоці коду, якщо функцію оголошено в блоці).
          </p>
        </div>
        <hr />

        <li class="question">
          Чим стрілочна функція відрізняється від звичайної?
        </li>
        <div class="answer">
          <p class="answer-text">
            Стрілочна функція не має власного this. Вона бере його за місцем
            створення. Стрілочна функція не має arguments. Стрілочна функція не
            має prototype. Стрілочна функція має короткий синтаксис неявного
            повернення значення.
          </p>
          <p class="answer-text">
            У звичайній функції this визначається під час виклику.
          </p>
        </div>
        <hr />

        <li class="question">
          Чи існує аналог arguments для стрілочної функції?
        </li>
        <div class="answer">
          <p class="answer-text">
            Аналога немає. Але можна використовувати rest оператор (...) для
            того, щоб зібрати в масив всі параметри, з якими викликана функція.
          </p>
        </div>
        <hr />

        <li class="question">
          Що таке лексичне оточення (Lexical Environment)?
        </li>
        <div class="answer">
          <p class="answer-text">
            Це властивості внутрішнього об'єкта функції, які створюються під час
            її виклику. Туди записуються аргументи, функції та змінні. Також там
            знаходиться посилання на зовнішнє лексичне оточення.
          </p>
        </div>
        <hr />

        <li class="question">Що є глобальним лексичним оточенням?</li>
        <div class="answer">
          <p class="answer-text">
            У несуворому режимі це window. У суворому - undefined.
          </p>
        </div>
        <hr />

        <li class="question">Що таке замикання (Closures)?</li>
        <div class="answer">
          <p class="answer-text">
            Це здатність функції під час створення запам'ятовувати посилання на
            змінні, функції та параметри, що знаходяться в поточному лексичному
            оточенні, а також у лексичному оточенні батьківської функції й так
            до глобального лексичного оточення. Замикання передбачає саме
            зовнішні змінні, а не саму функцію.
          </p>
        </div>
        <hr />

        <li class="question">Для чого використовують замикання?</li>
        <div class="answer">
          <ol class="answer-ol">
            <li>
              Найчастіше для створення приватних змінних та функцій
              (інкапсуляція).
            </li>
            <li>
              Для збереження проміжних параметрів виклику функції (каррування).
            </li>
          </ol>
        </div>
        <hr />

        <li class="question">Що таке IIFE?</li>
        <div class="answer">
          <p class="answer-text">
            Immediately Invoked Function Expression - це функція, яка
            викликається або виконується одразу після створення або оголошення.
          </p>
        </div>
        <hr />

        <li class="question">Що таке this?</li>
        <div class="answer">
          <p class="answer-text">
            Це посилання на контекст виклику функції. Контекстом є об'єкт, який
            в цей момент виконує або викликає функцію. Для стрілочної функції -
            це об'єкт у якому вона створена, а у звичайній функції - яким вона
            викликана. Контекстом може бути:
          </p>
          <ul class="answer-ul">
            <li>this в об'єкті - вказує на сам об'єкт;</li>
            <li>this в класі - вказує на екземпляр класу;</li>
            <li>
              глобальним контекстом є window (або undefined в режимі use
              strict).
            </li>
          </ul>
        </div>
        <hr />

        <li class="question">Як можна підмінити контекст виклику функції?</li>
        <div class="answer">
          <p class="answer-text">Є 3 методи: call, apply, bind.</p>
          <p class="answer-text">
            call та apply викликають функцію із заданим контекстом.
          </p>
          <p class="answer-text">
            bind повертає нову функцію із вже назавжди прив'язаним контекстом.
          </p>
        </div>
        <hr />

        <li class="question">
          Чи можна змінити контекст функції, яку повернув метод bind?
        </li>
        <div class="answer">
          <p class="answer-text">Ні, bind прив'язує контекст назавжди.</p>
        </div>
        <hr />

        <li class="question">
          Чи можна підмінити контекст виклику стрілочної функції?
        </li>
        <div class="answer">
          <p class="answer-text">
            Ні. Стрілочна функція не має методів call, apply, bind і своїх
            аналогів. Також вона використовує контекст у якому її створили, а не
            контекст у якому її викликали.
          </p>
        </div>
        <hr />

        <li class="question">Що таке прототип об'єкта?</li>
        <div class="answer">
          <p class="answer-text">
            Це шаблон об'єкта. Він використовується як запасний варіант для
            властивостей та методів, що існують у цьому об'єкті. Це також один
            зі способів обміну властивостями та функціональністю між об'єктами.
            Це основна концепція прототипного наслідування в JS.
          </p>
        </div>
        <hr />

        <li class="question">
          Як працює прототипне наслідування в JavaScript?
        </li>
        <div class="answer">
          <p class="answer-text">
            Коли ми хочемо прочитати властивість з об'єкта, а вона відсутня -
            JavaScript спробує прочитати його з прототипу об'єкта. Якщо
            властивості немає в прототипі, JavaScript намагатиметься його
            прочитати з прототипу прототипу, і т. д. доки властивість не буде
            знайдено або ланцюжок прототипів не закінчиться. У такому разі
            JavaScript поверне undefined.
          </p>
        </div>
        <hr />

        <li class="question">Як створити об'єкт у якому не буде прототипу?</li>
        <div class="answer">
          <p class="answer-text">
            Використати Object.create(). Цей метод приймає першим аргументом
            об'єкт, який буде прототипом об'єкта, який він поверне. Якщо ми
            викличемо Object.create() з аргументом null, буде створено об'єкт
            без прототипу.
          </p>
        </div>
        <hr />

        <li class="question">
          Як перевірити чи є властивість об'єкта особистою властивістю або це
          властивість прототипу?
        </li>
        <div class="answer">
          <p class="answer-text">
            Використати метод hasOwnProperty, який повертає true або false, в
            залежності від того, чи містить об'єкт зазначену властивість, як
            власну властивість, чи ні.
          </p>
        </div>
        <hr />

        <li class="question">Як заборонити змінювати об'єкт?</li>
        <div class="answer">
          <ul class="answer-ul">
            <li>
              Є метод Object.freeze(), який "заморожує" об'єкт від змін. Цей
              метод працює тільки в один бік. Скасувати дію цього методу вже
              неможливо.
            </li>
            <li>
              Є метод Object.seal(), який забороняє додавати нові властивості,
              але вже наявні властивості можна змінювати.
            </li>
            <li>
              Також є метод Object.preventExtensions(), який забороняє додавати
              нові властивості в об'єкт.
            </li>
          </ul>
        </div>
        <hr />

        <li class="question">Що таке дескриптори властивостей об'єкта?</li>
        <div class="answer">
          <p class="answer-text">
            Дескриптор - це об'єкт конфігурації властивості в об'єкті. Він має 4
            властивості:
          </p>
          <ul class="answer-ul">
            <li>value - значення властивості об'єкта;</li>
            <li>
              writable - вказує чи можна змінювати значення цієї властивості;
            </li>
            <li>
              enumerable - вказує чи буде видно властивість під час перебору
              властивостей об'єкта;
            </li>
            <li>
              configurable - вказує чи можна додавати або видаляти властивості
              об'єкта, а також чи можна змінювати дескриптори його властивостей.
            </li>
          </ul>
        </div>
        <hr />

        <li class="question">Чим відрізняється функція конструктор та клас?</li>
        <div class="answer">
          <p class="answer-text">
            Клас - це синтаксичний цукор над функцією конструктора. Під час
            створення екземпляра класу, методи описані в ньому потрапляють у
            прототип, а методи описані всередині функції конструктора потраплять
            у сам екземпляр. Для того, щоб методи, описані всередині функції
            конструктора, потрапили в прототип, їх потрібно окремо туди додати.
          </p>
        </div>
        <hr />

        <li class="question">
          Що потрібно зробити, щоб метод класу потрапив до його екземпляра?
        </li>
        <div class="answer">
          <p class="answer-text">
            Такий метод слід описати всередині конструктора.
          </p>
        </div>
        <hr />

        <li class="question">Чи є в JavaScript множинне наслідування?</li>
        <div class="answer">
          <p class="answer-text">
            Ні, тому що наслідування в JavaScript базується на прототипах, а в
            одного об'єкта може бути лише один прототип.
          </p>
        </div>
        <hr />

        <li class="question">Що таке Promise?</li>
        <div class="answer">
          <p class="answer-text">
            Це об'єкт, який використовують для відкладених та асинхронних
            обчислень. Promise має 3 стани:
          </p>
          <ul class="answer-ul">
            <li>
              очікування (pending): початковий стан, не виконаний та не
              відхилений;
            </li>
            <li>виконано (fulfilled): операцію завершено успішно;</li>
            <li>відхилено (rejected): операцію завершено з помилкою.</li>
          </ul>
        </div>
        <hr />

        <li class="question">Для чого потрібен метод Promise.all?</li>
        <div class="answer">
          <p class="answer-text">
            Цей метод очікує виконання всіх промісів або відхилення будь-якого з
            них. Повертає проміс, який виконається після виконання всіх
            промісів. У випадку, якщо будь-який з промісів буде відхилено,
            Promise.all також буде відхилено.
          </p>
          <p class="answer-text">
            У нього є аналог Promise.allSetled, який виконується як тільки всі
            отримані проміси завершені (виконані або відхилені), що містить
            масив результатів виконання отриманих промісів.
          </p>
        </div>
        <hr />

        <li class="question">Для чого потрібен метод Promise.race?</li>
        <div class="answer">
          <p class="answer-text">
            Очікує виконання або відхилення будь-якого з отриманих промісів.
            Повертає проміс, який буде виконано або відхилено з результатом
            виконання першого виконаного або відхиленого промісу.
          </p>
        </div>
        <hr />

        <li class="question">Для чого потрібна async/await функція?</li>
        <div class="answer">
          <p class="answer-text">
            Ключове слово async робить створену функцію асинхронною. Функція
            async може містити вираз await, який призупиняє виконання функції
            async і чекає відповіді від переданого Promise, потім відновлює
            виконання функції async і повертає отримане значення.
          </p>
        </div>
        <hr />

        <li class="question">Як обробляти помилки в async/await функції?</li>
        <div class="answer">
          <ol class="answer-ol">
            <li>Для цього можна використовувати конструкцію try...catch().</li>
            <li>Викликати метод .catch() після виклику функції.</li>
          </ol>
        </div>
        <hr />

        <li class="question">Що таке event loop?</li>
        <div class="answer">
          <p class="answer-text">
            Це механізм, який відповідає за виконання коду, збору та обробки
            подій та виконання підзадач із черги.
          </p>
          <p class="answer-text">У концепції event loop є кілька блоків:</p>
          <ul class="answer-ul">
            <li>
              call stack - відповідає за створення контексту виконання функції.
              Кожна функція, що викликається, потрапляє в call stack.
            </li>
            <li>
              heap - це велика не структурована область пам'яті, в якій
              зберігаються оголошені змінні, функції тощо.
            </li>
            <li>
              third party API - API, які надає оточення. Наприклад, метод fetch,
              який надається браузером.
            </li>
            <li>
              queue - список завдань, що підлягають обробці. Кожне завдання
              асоціюється з деякою функцією, яка буде викликана, щоб опрацювати
              це завдання.
            </li>
          </ul>
        </div>
        <hr />
      </ol>
    </main>

    <footer>
      <p class="footer-text">
        If you would like to contribute to this document, please write to
        <a
          href="mailto:vitaliy.shchukin@gmail.com?subject=Q%26A%3A%20Suggestion%20to%20add%20a%20question%20and%20answer"
          target="_blank"
          >me</a
        >.
      </p>
    </footer>
  </body>
</html>
